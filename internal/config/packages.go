package config

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/pelletier/go-toml/v2"
)

// PackagesConfig represents the user-defined packages configuration.
type PackagesConfig struct {
	Apt         AptConfig         `toml:"apt"`
	Brew        BrewConfig        `toml:"brew"`
	Cargo       CargoConfig       `toml:"cargo"`
	Npm         NpmConfig         `toml:"npm"`
	Pip         PipConfig         `toml:"pip"`
	Gems        GemsConfig        `toml:"gems"`
	PostInstall PostInstallConfig `toml:"post_install"`
	Tools       ToolsConfig       `toml:"tools"`
}

// AptConfig holds APT package settings.
type AptConfig struct {
	Packages []string `toml:"packages"`
}

// BrewConfig holds Homebrew package and tap settings.
type BrewConfig struct {
	Taps     []string `toml:"taps"`
	Packages []string `toml:"packages"`
}

// CargoConfig holds Cargo package settings.
type CargoConfig struct {
	Packages []string `toml:"packages"`
}

// NpmConfig holds NPM package settings.
type NpmConfig struct {
	Packages    []string `toml:"packages"`
	PostInstall []string `toml:"post_install"`
}

// PipConfig holds PIP package settings.
type PipConfig struct {
	Packages []string `toml:"packages"`
}

// GemsConfig holds Ruby gem package settings.
type GemsConfig struct {
	Packages []string `toml:"packages"`
}

// PostInstallConfig holds post-install commands.
type PostInstallConfig struct {
	Commands []string `toml:"commands"`
}

// ToolsConfig holds specialized tool toggles.
type ToolsConfig struct {
	PhpBrew bool `toml:"phpbrew"`
	Nix     bool `toml:"nix"`
	Nvm     bool `toml:"nvm"`
	Vmr     bool `toml:"vmr"`
	Asdf    bool `toml:"asdf"`
	Mise    bool `toml:"mise"`
	Volta   bool `toml:"volta"`
	Bun     bool `toml:"bun"`
}

// LoadPackages reads the packages.toml file.
func LoadPackages() (*PackagesConfig, error) {
	configPath := filepath.Join(GetConfigDir(), "packages.toml")

	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		return &PackagesConfig{}, nil
	}

	data, err := os.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read packages.toml: %w", err)
	}

	var config PackagesConfig
	if err := toml.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to parse packages.toml: %w", err)
	}

	return &config, nil
}

// SavePackages writes the packages config back to packages.toml.
func (c *PackagesConfig) SavePackages() error {
	configPath := filepath.Join(GetConfigDir(), "packages.toml")

	data, err := toml.Marshal(c)
	if err != nil {
		return fmt.Errorf("failed to marshal packages config: %w", err)
	}

	if err := os.WriteFile(configPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write packages.toml: %w", err)
	}

	return nil
}

// GenerateInstallScript generates a bash script to install configured packages.
func (c *PackagesConfig) GenerateInstallScript() string {
	script := "#!/bin/bash\n# Generated by Construct CLI - DO NOT EDIT\n\nset -e\n\n"

	// Sudo helper: detect if we need sudo and if it's functional
	script += "# Sudo detection: skip if root, test if sudo works, otherwise skip privileged ops\n"
	script += "SUDO_AVAILABLE=1\n"
	script += "if [ \"$(id -u)\" = \"0\" ]; then\n"
	script += "    SUDO=\"\"\n"
	script += "elif sudo -n true 2>/dev/null; then\n"
	script += "    SUDO=\"sudo\"\n"
	script += "else\n"
	script += "    echo '⚠️  sudo not available or not configured - skipping privileged package operations'\n"
	script += "    SUDO_AVAILABLE=0\n"
	script += "fi\n\n"

	// Diagnostics (helps troubleshoot UID/GID, PATH and package manager issues)
	script += "echo '=== Construct setup diagnostics ==='\n"
	script += "echo \"Timestamp (UTC): $(date -u +%Y-%m-%dT%H:%M:%SZ)\"\n"
	script += "echo \"User IDs: uid=$(id -u) gid=$(id -g)\"\n"
	script += "echo \"User names: user=$(id -un 2>/dev/null || echo unknown) group=$(id -gn 2>/dev/null || echo unknown)\"\n"
	script += "echo \"HOME: $HOME\"\n"
	script += "echo \"SHELL: ${SHELL:-unknown}\"\n"
	script += "echo \"PATH: $PATH\"\n"
	script += "if [ -d /home/linuxbrew/.linuxbrew ]; then\n"
	script += "    if [ -w /home/linuxbrew/.linuxbrew ]; then\n"
	script += "        echo \"Homebrew dir writable: /home/linuxbrew/.linuxbrew\"\n"
	script += "    else\n"
	script += "        echo \"⚠️ Homebrew dir not writable by current user: /home/linuxbrew/.linuxbrew\"\n"
	script += "        ls -ld /home/linuxbrew/.linuxbrew 2>/dev/null || true\n"
	script += "    fi\n"
	script += "fi\n"
	script += "if command -v brew &> /dev/null; then\n"
	script += "    echo \"brew: $(command -v brew)\"\n"
	script += "    brew --version | head -1 || true\n"
	script += "else\n"
	script += "    echo \"brew: not found\"\n"
	script += "fi\n"
	script += "if command -v npm &> /dev/null; then\n"
	script += "    echo \"npm: $(command -v npm)\"\n"
	script += "    npm --version || true\n"
	script += "else\n"
	script += "    echo \"npm: not found\"\n"
	script += "fi\n"
	script += "echo '=================================='\n\n"

	// Critical Packages (Safety check - ensure Dockerfile packages are present)
	script += "# Critical Packages (only if sudo available)\n"
	script += "if [ \"$SUDO_AVAILABLE\" = \"1\" ]; then\n"
	script += "    echo 'Verifying critical packages...'\n"
	script += "    $SUDO apt-get update\n"
	script += "    $SUDO apt-get install -y build-essential git curl wget sudo gosu socat bubblewrap xvfb\n"
	script += "fi\n\n"

	// Core APT Packages (Always installed, only if sudo available)
	script += "if [ \"$SUDO_AVAILABLE\" = \"1\" ]; then\n"
	script += "    echo 'Installing core system packages...'\n"
	script += "    $SUDO apt-get install -y procps file nano python3 python3-pip python3-venv python3-dev pipx ufw iptables dnsutils xclip xsel wl-clipboard\n"
	script += "fi\n\n"

	// Initialize Homebrew environment
	script += "# Initialize Homebrew environment\n"
	script += "if [ -f /home/linuxbrew/.linuxbrew/bin/brew ]; then\n"
	script += "    eval \"$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\"\n"
	script += "fi\n\n"

	// Configure npm before global installs to avoid EACCES on /usr/local with non-root UIDs
	script += "echo 'Configuring npm global prefix...'\n"
	script += "if command -v npm &> /dev/null; then\n"
	script += "    mkdir -p \"$HOME/.npm-global\"\n"
	script += "    npm config set prefix \"$HOME/.npm-global\" || echo \"⚠️ Failed to set npm prefix\"\n"
	script += "    export PATH=\"$HOME/.npm-global/bin:$PATH\"\n"
	script += "    echo \"npm global prefix: $(npm config get prefix 2>/dev/null || echo unknown)\"\n"
	script += "else\n"
	script += "    echo \"⚠️ npm not found; skipping npm prefix configuration\"\n"
	script += "fi\n\n"

	// Standard Tools (Always installed)
	script += "echo 'Installing Claude Code...'\n"
	script += "if [ -x \"/home/construct/.local/bin/claude\" ]; then\n"
	script += "    echo \"Claude already installed; skipping.\"\n"
	script += "else\n"
	script += "    curl -fsSL https://claude.ai/install.sh | bash\n"
	script += "fi\n\n"

	script += "echo 'Installing Amp CLI...'\n"
	script += "if [ -x \"/home/construct/.local/bin/amp\" ] || [ -x \"/home/construct/.amp/bin/amp\" ]; then\n"
	script += "    echo \"Amp already installed; skipping.\"\n"
	script += "else\n"
	script += "    curl -fsSL https://ampcode.com/install.sh | bash\n"
	script += "fi\n\n"

	script += "echo 'Installing imagemagick (required for clipboard)...'\n"
	script += "if command -v brew &> /dev/null; then\n"
	script += "    brew install imagemagick || echo \"⚠️ Failed to install imagemagick\"\n"
	script += "else\n"
	script += "    echo \"⚠️ Homebrew not found; skipping imagemagick\"\n"
	script += "fi\n\n"

	script += "echo 'Installing topgrade (system updater)...'\n"
	script += "if command -v brew &> /dev/null; then\n"
	script += "    brew install topgrade || echo \"⚠️ Failed to install topgrade\"\n"
	script += "else\n"
	script += "    echo \"⚠️ Homebrew not found; skipping topgrade\"\n"
	script += "fi\n\n"

	script += "echo 'Installing cargo-update (enables cargo package updates)...'\n"
	script += "if command -v cargo &> /dev/null; then\n"
	script += "    # Install libgit2 via Homebrew first (dependency for cargo-update)\n"
	script += "    if command -v brew &> /dev/null; then\n"
	script += "        brew install libgit2 || echo \"Warning: libgit2 installation failed\"\n"
	script += "    fi\n"
	script += "    cargo install cargo-update 2>/dev/null || echo \"Warning: cargo-update installation failed, cargo package updates disabled\"\n"
	script += "fi\n\n"

	// Specialized Tools (Priority)
	if c.Tools.PhpBrew {
		script += "echo 'Installing PHPBrew...'\n"
		script += "mkdir -p $HOME/.local/bin\n"
		script += "curl -L -O https://github.com/phpbrew/phpbrew/releases/latest/download/phpbrew.phar\n"
		script += "chmod +x phpbrew.phar\n"
		script += "mv phpbrew.phar $HOME/.local/bin/phpbrew\n"
		script += "phpbrew init\n"
		script += "phpbrew lookup-prefix homebrew\n\n"
	}

	if c.Tools.Nix {
		script += "echo 'Installing Nix...'\n"
		script += "sh <(curl --proto '=https' --tlsv1.2 -L https://nixos.org/nix/install) --no-daemon\n\n"
	}

	if c.Tools.Nvm {
		script += "echo 'Installing NVM...'\n"
		script += "curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash\n\n"
	}

	if c.Tools.Vmr {
		script += "echo 'Installing VMR...'\n"
		script += "curl --proto '=https' --tlsv1.2 -sSf https://scripts.vmr.dpdns.org | sh\n\n"
	}

	if c.Tools.Asdf {
		script += "echo 'Installing asdf via Homebrew...'\n"
		script += "if command -v brew &> /dev/null; then\n"
		script += "    brew install asdf || echo \"⚠️ Failed to install asdf\"\n"
		script += "else\n"
		script += "    echo \"⚠️ Homebrew not found; skipping asdf\"\n"
		script += "fi\n\n"
	}

	if c.Tools.Mise {
		script += "echo 'Installing mise...'\n"
		script += "curl https://mise.run | sh\n\n"
	}

	if c.Tools.Volta {
		script += "echo 'Installing Volta...'\n"
		script += "curl https://get.volta.sh | bash -s -- --skip-setup\n\n"
	}

	if c.Tools.Bun {
		script += "echo 'Installing Bun...'\n"
		script += "curl -fsSL https://bun.com/install | bash\n"
		script += "export PATH=\"$HOME/.bun/bin:$PATH\"\n\n"
	}

	// APT (only if sudo available)
	if len(c.Apt.Packages) > 0 {
		script += "if [ \"$SUDO_AVAILABLE\" = \"1\" ]; then\n"
		script += "    echo 'Installing APT packages...'\n"
		script += "    $SUDO apt-get update\n"
		script += "    $SUDO apt-get install -y "
		for _, pkg := range c.Apt.Packages {
			script += pkg + " "
		}
		script += "\n"
		script += "fi\n\n"
	}

	// Brew
	if len(c.Brew.Taps) > 0 || len(c.Brew.Packages) > 0 {
		script += "echo 'Installing Homebrew packages...'\n"
		script += "if command -v brew &> /dev/null; then\n"
		for _, tap := range c.Brew.Taps {
			script += "    if ! brew tap " + tap + "; then\n"
			script += "        echo \"⚠️ Failed to tap " + tap + "\"\n"
			script += "    fi\n"
		}
		if len(c.Brew.Packages) > 0 {
			for _, pkg := range c.Brew.Packages {
				// Use --formula to avoid disambiguation errors with tap-qualified names
				script += "    if ! brew install --formula " + pkg + "; then\n"
				script += "        echo \"⚠️ Failed to install " + pkg + "\"\n"
				script += "    fi\n"
			}
		}
		script += "else\n"
		script += "    echo \"⚠️ Homebrew not found; skipping Homebrew packages\"\n"
		script += "fi\n"
		script += "\n"
	}

	// Cargo
	if len(c.Cargo.Packages) > 0 {
		script += "echo 'Installing Cargo packages...'\n"
		script += "# Ensure cargo is in PATH\n"
		script += "if command -v cargo &> /dev/null; then\n"
		for _, pkg := range c.Cargo.Packages {
			script += "    cargo install " + pkg + " || echo \"⚠️ Failed to install " + pkg + "\"\n"
		}
		script += "else\n"
		script += "    echo \"⚠️ Cargo not found; skipping Rust packages\"\n"
		script += "fi\n\n"
	}

	// NPM
	if len(c.Npm.Packages) > 0 {
		script += "echo 'Installing NPM packages...'\n"
		for _, pkg := range c.Npm.Packages {
			script += "npm install -g " + pkg + " || echo \"⚠️ Failed to install " + pkg + "\"\n"
		}
		script += "\n\n"
	}
	if len(c.Npm.PostInstall) > 0 {
		script += "echo 'Running NPM post-install commands...'\n"
		script += "export NPM_CONFIG_YES=true\n"
		for _, cmd := range c.Npm.PostInstall {
			script += cmd + "\n"
		}
		script += "\n"
	}

	// PIP (using pipx for PEP 668 compliance)
	if len(c.Pip.Packages) > 0 {
		script += "echo 'Installing PIP packages via pipx...'\n"
		script += "# Ensure pipx PATH is configured\n"
		script += "export PATH=\"$HOME/.local/bin:$PATH\"\n"
		script += "if command -v pipx &> /dev/null; then\n"
		for _, pkg := range c.Pip.Packages {
			script += "    pipx install " + pkg + " || echo \"⚠️ Failed to install " + pkg + "\"\n"
		}
		script += "else\n"
		script += "    echo \"⚠️ pipx not found; skipping Python packages\"\n"
		script += "fi\n\n"
	}

	// Gems
	if len(c.Gems.Packages) > 0 {
		script += "echo 'Installing Ruby gems...'\n"
		script += "# Ensure gem is in PATH\n"
		script += "if command -v gem &> /dev/null; then\n"
		for _, pkg := range c.Gems.Packages {
			script += "    gem install " + pkg + " || echo \"⚠️ Failed to install " + pkg + "\"\n"
		}
		script += "else\n"
		script += "    echo \"⚠️ Gem not found; skipping Ruby packages\"\n"
		script += "fi\n\n"
	}

	// Post-install
	if len(c.PostInstall.Commands) > 0 {
		script += "echo 'Running post-install commands...'\n"
		script += "export NPM_CONFIG_YES=true\n"
		for _, cmd := range c.PostInstall.Commands {
			script += cmd + "\n"
		}
		script += "\n"
	}

	script += "echo 'Post-install command verification...'\n"
	script += "missing_cmds=\"\"\n"
	script += "for cmd in claude amp copilot opencode qwen cline codex goose gemini kilocode pi; do\n"
	script += "    if command -v \"$cmd\" &> /dev/null; then\n"
	script += "        cmd_path=$(command -v \"$cmd\")\n"
	script += "        echo \"  ✓ $cmd -> $cmd_path\"\n"
	script += "    else\n"
	script += "        echo \"  - $cmd not found in PATH\"\n"
	script += "        missing_cmds=\"$missing_cmds $cmd\"\n"
	script += "    fi\n"
	script += "done\n\n"
	script += "if [ -n \"$missing_cmds\" ]; then\n"
	script += "    echo \"⚠️ Missing commands after setup:$missing_cmds\"\n"
	script += "    echo \"   If these agents are expected, re-run: construct sys packages --install\"\n"
	script += "fi\n\n"

	script += "echo 'User package installation completed successfully.'\n"
	return script
}

// GenerateTopgradeConfig generates a topgrade.toml configuration based on enabled tools.
func (c *PackagesConfig) GenerateTopgradeConfig() string {
	var disabledSteps []string

	baseDisabled := []string{
		"firmware",
		"flatpak",
		"snap",
		"containers",
		"sdkman",
		"vagrant",
		"wsl",
		"lensfun",
		"vim",
		"emacs",
		"vscode",
		"atom",
		"git_repos",
		"gnome_shell_extensions",
		"rcm",
		"remotes",
		"restarts",
		"shell",
		"sparkle",
		"tmux",
		"toolbx",
	}
	disabledSteps = append(disabledSteps, baseDisabled...)

	if !c.Tools.Nix {
		disabledSteps = append(disabledSteps, "nix")
	}
	if !c.Tools.Nvm {
		disabledSteps = append(disabledSteps, "node")
	}
	if !c.Tools.Asdf {
		disabledSteps = append(disabledSteps, "asdf")
	}
	if !c.Tools.Mise {
		disabledSteps = append(disabledSteps, "mise")
	}
	if !c.Tools.Volta {
		disabledSteps = append(disabledSteps, "volta_packages")
	}
	if !c.Tools.Bun {
		disabledSteps = append(disabledSteps, "bun")
	}
	// Always disable pip3 (PEP 668 compliance), only enable pipx when pip packages exist
	disabledSteps = append(disabledSteps, "pip3")
	if len(c.Pip.Packages) == 0 {
		disabledSteps = append(disabledSteps, "pipx")
	}
	if len(c.Gems.Packages) == 0 {
		disabledSteps = append(disabledSteps, "gem")
	}

	config := "[misc]\n"
	config += "assume_yes = true\n"
	config += "no_retry = true\n"
	config += "no_self_update = true\n"
	config += "pre_sudo = true\n"
	config += "show_skipped = false\n"
	config += "display_time = true\n"
	config += "disable = [\n"
	for _, step := range disabledSteps {
		config += fmt.Sprintf("    %q,\n", step)
	}
	config += "]\n\n"

	config += "[brew]\n"
	config += "autoremove = true\n"
	config += "greedy_cask = true\n\n"

	config += "[npm]\n"
	config += "use_sudo = false\n\n"

	config += "[yarn]\n"
	config += "use_sudo = false\n\n"

	config += "[git]\n"
	config += "pull_predefined = false\n\n"

	config += "[composer]\n"
	config += "self_update = false\n\n"

	config += "[commands]\n"
	config += "\"Claude Code\" = \"claude update\"\n"

	return config
}
