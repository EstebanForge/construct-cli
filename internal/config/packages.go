package config

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/pelletier/go-toml/v2"
)

// PackagesConfig represents the user-defined packages configuration.
type PackagesConfig struct {
	Apt         AptConfig         `toml:"apt"`
	Brew        BrewConfig        `toml:"brew"`
	Cargo       CargoConfig       `toml:"cargo"`
	Npm         NpmConfig         `toml:"npm"`
	Pip         PipConfig         `toml:"pip"`
	Gems        GemsConfig        `toml:"gems"`
	PostInstall PostInstallConfig `toml:"post_install"`
	Tools       ToolsConfig       `toml:"tools"`
}

// AptConfig holds APT package settings.
type AptConfig struct {
	Packages []string `toml:"packages"`
}

// BrewConfig holds Homebrew package and tap settings.
type BrewConfig struct {
	Taps     []string `toml:"taps"`
	Packages []string `toml:"packages"`
}

// CargoConfig holds Cargo package settings.
type CargoConfig struct {
	Packages []string `toml:"packages"`
}

// NpmConfig holds NPM package settings.
type NpmConfig struct {
	Packages    []string `toml:"packages"`
	PostInstall []string `toml:"post_install"`
}

// PipConfig holds PIP package settings.
type PipConfig struct {
	Packages []string `toml:"packages"`
}

// GemsConfig holds Ruby gem package settings.
type GemsConfig struct {
	Packages []string `toml:"packages"`
}

// PostInstallConfig holds post-install commands.
type PostInstallConfig struct {
	Commands []string `toml:"commands"`
}

// ToolsConfig holds specialized tool toggles.
type ToolsConfig struct {
	PhpBrew bool `toml:"phpbrew"`
	Nix     bool `toml:"nix"`
	Nvm     bool `toml:"nvm"`
	Vmr     bool `toml:"vmr"`
	Asdf    bool `toml:"asdf"`
	Mise    bool `toml:"mise"`
	Volta   bool `toml:"volta"`
	Bun     bool `toml:"bun"`
}

// LoadPackages reads the packages.toml file.
func LoadPackages() (*PackagesConfig, error) {
	configPath := filepath.Join(GetConfigDir(), "packages.toml")

	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		return &PackagesConfig{}, nil
	}

	data, err := os.ReadFile(configPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read packages.toml: %w", err)
	}

	var config PackagesConfig
	if err := toml.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to parse packages.toml: %w", err)
	}

	return &config, nil
}

// SavePackages writes the packages config back to packages.toml.
func (c *PackagesConfig) SavePackages() error {
	configPath := filepath.Join(GetConfigDir(), "packages.toml")

	data, err := toml.Marshal(c)
	if err != nil {
		return fmt.Errorf("failed to marshal packages config: %w", err)
	}

	if err := os.WriteFile(configPath, data, 0644); err != nil {
		return fmt.Errorf("failed to write packages.toml: %w", err)
	}

	return nil
}

// GenerateInstallScript generates a bash script to install configured packages.
func (c *PackagesConfig) GenerateInstallScript() string {
	script := "#!/bin/bash\n# Generated by Construct CLI - DO NOT EDIT\n\nset -e\n\n"

	// Sudo helper: detect if we need sudo and if it's functional
	script += "# Sudo detection: skip if root, test if sudo works, otherwise skip privileged ops\n"
	script += "SUDO_AVAILABLE=1\n"
	script += "if [ \"$(id -u)\" = \"0\" ]; then\n"
	script += "    SUDO=\"\"\n"
	script += "elif sudo -n true 2>/dev/null; then\n"
	script += "    SUDO=\"sudo\"\n"
	script += "else\n"
	script += "    echo '⚠️  sudo not available or not configured - skipping privileged package operations'\n"
	script += "    SUDO_AVAILABLE=0\n"
	script += "fi\n\n"

	// Critical Packages (Safety check - ensure Dockerfile packages are present)
	script += "# Critical Packages (only if sudo available)\n"
	script += "if [ \"$SUDO_AVAILABLE\" = \"1\" ]; then\n"
	script += "    echo 'Verifying critical packages...'\n"
	script += "    $SUDO apt-get update\n"
	script += "    $SUDO apt-get install -y build-essential git curl wget sudo gosu socat bubblewrap xvfb\n"
	script += "fi\n\n"

	// Core APT Packages (Always installed, only if sudo available)
	script += "if [ \"$SUDO_AVAILABLE\" = \"1\" ]; then\n"
	script += "    echo 'Installing core system packages...'\n"
	script += "    $SUDO apt-get install -y procps file nano python3 python3-pip python3-venv python3-dev pipx ufw iptables dnsutils xclip xsel wl-clipboard\n"
	script += "fi\n\n"

	// Initialize Homebrew environment
	script += "# Initialize Homebrew environment\n"
	script += "if [ -f /home/linuxbrew/.linuxbrew/bin/brew ]; then\n"
	script += "    eval \"$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\"\n"
	script += "fi\n\n"

	// Standard Tools (Always installed)
	script += "echo 'Installing Claude Code...'\n"
	script += "if [ -x \"/home/construct/.local/bin/claude\" ]; then\n"
	script += "    echo \"Claude already installed; skipping.\"\n"
	script += "else\n"
	script += "    curl -fsSL https://claude.ai/install.sh | bash\n"
	script += "fi\n\n"

	script += "echo 'Installing Amp CLI...'\n"
	script += "if [ -x \"/home/construct/.local/bin/amp\" ] || [ -x \"/home/construct/.amp/bin/amp\" ]; then\n"
	script += "    echo \"Amp already installed; skipping.\"\n"
	script += "else\n"
	script += "    curl -fsSL https://ampcode.com/install.sh | bash\n"
	script += "fi\n\n"

	script += "echo 'Installing imagemagick (required for clipboard)...'\n"
	script += "brew install imagemagick\n\n"

	script += "echo 'Installing topgrade (system updater)...'\n"
	script += "brew install topgrade\n\n"

	script += "echo 'Installing cargo-update (enables cargo package updates)...'\n"
	script += "if command -v cargo &> /dev/null; then\n"
	script += "    # Install libgit2 via Homebrew first (dependency for cargo-update)\n"
	script += "    brew install libgit2\n"
	script += "    cargo install cargo-update 2>/dev/null || echo \"Warning: cargo-update installation failed, cargo package updates disabled\"\n"
	script += "fi\n\n"

	// Specialized Tools (Priority)
	if c.Tools.PhpBrew {
		script += "echo 'Installing PHPBrew...'\n"
		script += "mkdir -p $HOME/.local/bin\n"
		script += "curl -L -O https://github.com/phpbrew/phpbrew/releases/latest/download/phpbrew.phar\n"
		script += "chmod +x phpbrew.phar\n"
		script += "mv phpbrew.phar $HOME/.local/bin/phpbrew\n"
		script += "phpbrew init\n"
		script += "phpbrew lookup-prefix homebrew\n\n"
	}

	if c.Tools.Nix {
		script += "echo 'Installing Nix...'\n"
		script += "sh <(curl --proto '=https' --tlsv1.2 -L https://nixos.org/nix/install) --no-daemon\n\n"
	}

	if c.Tools.Nvm {
		script += "echo 'Installing NVM...'\n"
		script += "curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash\n\n"
	}

	if c.Tools.Vmr {
		script += "echo 'Installing VMR...'\n"
		script += "curl --proto '=https' --tlsv1.2 -sSf https://scripts.vmr.dpdns.org | sh\n\n"
	}

	if c.Tools.Asdf {
		script += "echo 'Installing asdf via Homebrew...'\n"
		script += "brew install asdf\n\n"
	}

	if c.Tools.Mise {
		script += "echo 'Installing mise...'\n"
		script += "curl https://mise.run | sh\n\n"
	}

	if c.Tools.Volta {
		script += "echo 'Installing Volta...'\n"
		script += "curl https://get.volta.sh | bash -s -- --skip-setup\n\n"
	}

	if c.Tools.Bun {
		script += "echo 'Installing Bun...'\n"
		script += "curl -fsSL https://bun.com/install | bash\n"
		script += "export PATH=\"$HOME/.bun/bin:$PATH\"\n\n"
	}

	// APT (only if sudo available)
	if len(c.Apt.Packages) > 0 {
		script += "if [ \"$SUDO_AVAILABLE\" = \"1\" ]; then\n"
		script += "    echo 'Installing APT packages...'\n"
		script += "    $SUDO apt-get update\n"
		script += "    $SUDO apt-get install -y "
		for _, pkg := range c.Apt.Packages {
			script += pkg + " "
		}
		script += "\n"
		script += "fi\n\n"
	}

	// Brew
	if len(c.Brew.Taps) > 0 || len(c.Brew.Packages) > 0 {
		script += "echo 'Installing Homebrew packages...'\n"
		for _, tap := range c.Brew.Taps {
			script += "brew tap " + tap + "\n"
		}
		if len(c.Brew.Packages) > 0 {
			for _, pkg := range c.Brew.Packages {
				// Use --formula to avoid disambiguation errors with tap-qualified names
				script += "if ! brew install --formula " + pkg + "; then\n"
				script += "    echo \"⚠️ Failed to install " + pkg + "\"\n"
				script += "fi\n"
			}
		}
		script += "\n"
	}

	// Cargo
	if len(c.Cargo.Packages) > 0 {
		script += "echo 'Installing Cargo packages...'\n"
		script += "# Ensure cargo is in PATH\n"
		script += "if command -v cargo &> /dev/null; then\n"
		for _, pkg := range c.Cargo.Packages {
			script += "    cargo install " + pkg + "\n"
		}
		script += "else\n"
		script += "    echo \"⚠️ Cargo not found; skipping Rust packages\"\n"
		script += "fi\n\n"
	}

	// NPM
	if len(c.Npm.Packages) > 0 {
		script += "echo 'Installing NPM packages...'\n"
		script += "npm install -g "
		for _, pkg := range c.Npm.Packages {
			script += pkg + " "
		}
		script += "\n\n"
	}
	if len(c.Npm.PostInstall) > 0 {
		script += "echo 'Running NPM post-install commands...'\n"
		script += "export NPM_CONFIG_YES=true\n"
		for _, cmd := range c.Npm.PostInstall {
			script += cmd + "\n"
		}
		script += "\n"
	}

	// PIP (using pipx for PEP 668 compliance)
	if len(c.Pip.Packages) > 0 {
		script += "echo 'Installing PIP packages via pipx...'\n"
		script += "# Ensure pipx PATH is configured\n"
		script += "export PATH=\"$HOME/.local/bin:$PATH\"\n"
		script += "if command -v pipx &> /dev/null; then\n"
		for _, pkg := range c.Pip.Packages {
			script += "    pipx install " + pkg + " || echo \"⚠️ Failed to install " + pkg + "\"\n"
		}
		script += "else\n"
		script += "    echo \"⚠️ pipx not found; skipping Python packages\"\n"
		script += "fi\n\n"
	}

	// Gems
	if len(c.Gems.Packages) > 0 {
		script += "echo 'Installing Ruby gems...'\n"
		script += "# Ensure gem is in PATH\n"
		script += "if command -v gem &> /dev/null; then\n"
		for _, pkg := range c.Gems.Packages {
			script += "    gem install " + pkg + "\n"
		}
		script += "else\n"
		script += "    echo \"⚠️ Gem not found; skipping Ruby packages\"\n"
		script += "fi\n\n"
	}

	// Post-install
	if len(c.PostInstall.Commands) > 0 {
		script += "echo 'Running post-install commands...'\n"
		script += "export NPM_CONFIG_YES=true\n"
		for _, cmd := range c.PostInstall.Commands {
			script += cmd + "\n"
		}
		script += "\n"
	}

	script += "echo 'User package installation completed successfully.'\n"
	return script
}

// GenerateTopgradeConfig generates a topgrade.toml configuration based on enabled tools.
func (c *PackagesConfig) GenerateTopgradeConfig() string {
	var disabledSteps []string

	baseDisabled := []string{
		"firmware",
		"flatpak",
		"snap",
		"containers",
		"sdkman",
		"vagrant",
		"wsl",
		"lensfun",
		"vim",
		"emacs",
		"vscode",
		"atom",
		"git_repos",
		"gnome_shell_extensions",
		"rcm",
		"remotes",
		"restarts",
		"shell",
		"sparkle",
		"tmux",
		"toolbx",
	}
	disabledSteps = append(disabledSteps, baseDisabled...)

	if !c.Tools.Nix {
		disabledSteps = append(disabledSteps, "nix")
	}
	if !c.Tools.Nvm {
		disabledSteps = append(disabledSteps, "node")
	}
	if !c.Tools.Asdf {
		disabledSteps = append(disabledSteps, "asdf")
	}
	if !c.Tools.Mise {
		disabledSteps = append(disabledSteps, "mise")
	}
	if !c.Tools.Volta {
		disabledSteps = append(disabledSteps, "volta_packages")
	}
	if !c.Tools.Bun {
		disabledSteps = append(disabledSteps, "bun")
	}
	// Always disable pip3 (PEP 668 compliance), only enable pipx when pip packages exist
	disabledSteps = append(disabledSteps, "pip3")
	if len(c.Pip.Packages) == 0 {
		disabledSteps = append(disabledSteps, "pipx")
	}
	if len(c.Gems.Packages) == 0 {
		disabledSteps = append(disabledSteps, "gem")
	}

	config := "[misc]\n"
	config += "assume_yes = true\n"
	config += "no_retry = true\n"
	config += "no_self_update = true\n"
	config += "pre_sudo = true\n"
	config += "show_skipped = false\n"
	config += "display_time = true\n"
	config += "disable = [\n"
	for _, step := range disabledSteps {
		config += fmt.Sprintf("    %q,\n", step)
	}
	config += "]\n\n"

	config += "[brew]\n"
	config += "autoremove = true\n"
	config += "greedy_cask = true\n\n"

	config += "[npm]\n"
	config += "use_sudo = false\n\n"

	config += "[yarn]\n"
	config += "use_sudo = false\n\n"

	config += "[git]\n"
	config += "pull_predefined = false\n\n"

	config += "[composer]\n"
	config += "self_update = false\n\n"

	config += "[commands]\n"
	config += "\"Claude Code\" = \"claude update\"\n"

	return config
}
